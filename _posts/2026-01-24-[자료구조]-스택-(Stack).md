---
title : "[자료구조] 스택 (Stack)"
date : 2026-01-24 17:48:00 +0900
categories : [Dev / CS]
tags : [computer, science, cpp, opp, stack]
comments : true
pin : true
---

## 스택 (Stack)

### 1. 스택 (Stack)
**스택 (Stack)** 이란 **후입선출 (LIFO)** 형식의 자료구조이다.
가장 나중에 삽입된 요소가 가장 먼저 나오게 된다.
![Desktop View](/assets/img/stack1.jpg){: w="700" h="400" }

<br/>

-----------------

<br/>

### **2. 스택의 주요 연산**
- push(data) : 데이터 삽입
- pop() : 맨 위 데이터 제거
- top() : 맨 위 데이터 확인
- empty() : 스택이 비어있는지 확인

#### **주요 연산 사용 예시**
```cpp
#include <stack>
#include <iostream>

using namespace std;

int main()
{
	stack<int> s;
	
	s.push(10);
	s.push(20);
	s.push(30);
	cout << s.top() << "\n";	// 30
	
	s.pop();
	cout << s.top() << "\n";	//20

	cout << s.empty() << "\n";	// 0
}
```
<br/>

-----------------

<br/>

### **3. 스택의 사용 예시**
- 괄호 검사
- 되돌리기 / 다시 실행
- 함수 호출 스택
- 수식 계산 (후위 표기)
- DFS (깊이 우선 탐색)
- 문자열 역순 계산

<br/>

-----------------

<br/>

### **3. 스택의 구현**
```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

template <typename T>
class Stack
{
private:
	T* data;
	size_t capacity;
	int top;

public:
	Stack(int capacity = 10)
	{
		this->capacity = capacity;
		top = 0;
		data = new T[capacity];
	}

	~Stack()
	{
		delete[] data;
	}

	size_t size()
	{
		return static_cast<size_t>(top);
	}

	void resize()
	{
		size_t newCapacity = capacity * 2;
		T* newData = new T[newCapacity];

		for (int i = 0; i < top; i++)
		{
			newData[i] = data[i];
		}

		delete[] data;

		data = newData;
		capacity = newCapacity;
	}

	void push(T temp)
	{
		if (isFull())
		{
			resize();
		}

		data[top++] = temp;
	}

	T pop()
	{
		if (isEmpty())
		{
			throw runtime_error("Stack is Empty.");
		}

		return data[--top];
	}

	T peek()
	{
		return data[top - 1];
	}

	bool isEmpty()
	{
		return top == 0;
	}

	bool isFull()
	{
		return static_cast<size_t>(top) >= capacity;
	}
};

int main()
{
	Stack<int> s(3);

	cout << "스택 비었나? " << s.isEmpty() << endl;

	cout << "push 시작" << endl;
	s.push(10);
	s.push(20);
	s.push(30);

	cout << "top 값: " << s.peek() << endl;

	s.push(40);
	cout << "resize 후 top 값: " << s.peek() << endl;

	cout << "현재 size: " << s.size() << endl;

	cout << "pop: " << s.pop() << endl;
	cout << "pop: " << s.pop() << endl;
	cout << "pop: " << s.pop() << endl;
	cout << "pop: " << s.pop() << endl;

	cout << "스택 비었나? " << s.isEmpty() << endl;

	try {
		s.pop();
	}
	catch (const runtime_error& e) {
		cout << "예외 발생: " << e.what() << endl;
	}

	return 0;
}
```
