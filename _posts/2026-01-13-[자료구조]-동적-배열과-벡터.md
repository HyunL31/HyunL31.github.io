---
title : "[자료구조] 동적 배열과 벡터"
date : 2026-01-13 19:03:00 +0900
categories : [Dev / CS]
tags : [computer, science, data, structure, stl, array, vector]
comments : true
pin : true
---

## 동적 배열과 벡터

### **1. 동적 배열**
런타임에 크기를 바꿀 수 있는 배열이다.
프로그램이 실행되는 중에 메모리로 새로 할당하여 사용한다.

#### **동적 배열의 장단점**
1. **장점**
	- 실행 중에 크기를 바꿀 수 있다.
	- 배열처럼 인덱스로 빠르게 접근할 수 있다.

2. **단점**
	- 직접 메모리를 해제해줘야 한다.
	- 메모리 크기를 변경하기 위해 새로 메모리를 할당하고 복사해야 한다.

##### **예시**
```cpp
int n;
cin >> n;
int* arr = new int[n];

arr[0] = 10;

delete[] arr;
```

<br/>

-----------------

<br/>

### **2. 벡터 (Vector)**

C++ STL에서 제공하는 <span style="background-color:#FFE6E6"> **동적배열** </span>이다.
배열처럼 연속된 메모리에 저장되지만 크기를 바꿀 수 있다.

##### **예시**
```cpp
#include <vector>
vector<int> v;
```
- `vector` : 벡터 선언
-   `<>` : 벡터의 자료형
-   `v` : 벡터 이름
 
<br/>

#### **벡터의 특징**
1. **동적 할당**
	- 실행 중에 크기를 변경할 수 있다.
	- 메모리가 부족하면 자동으로 더 큰 메모리를 할당하고 요소들을 복사한다.
 
2. **연속적인 메모리**
	- 연속적인 메모리에 데이터가 저장되기 때문에 원하는 요소에 $O(1)$ 시간에 접근할 수 있다.

3. **자동 메모리 관리**
	- 메모리의 할당과 해제를 자동으로 해준다.
	- 메모리 누수 위험이 거의 없다.

<br/>

#### **벡터 사용 예시**
```cpp
#include <vector>

// 벡터 선언
vector<int> v1;
vector<int> v2(10);
vector<int> v3(3, 5);
vector<int> v4 = {1, 2, 3};

v1.push_back(10);	// 벡터 끝에 요소 삽입
v1.empty();	// 벡터가 비어있는지 확인
v1.size();	// 벡터 크기 확인
v1.pop_back();	// 벡터 마지막 요소 삭제
v1.clear();		// 벡터 요소, 크기 초기화
```

<br/>

#### **벡터의 크기와 용량**
벡터는 크기와 용량을 가진다.
벡터의 크기(Size)는 벡터가 가진 요소의 개수를 의미한다.
벡터의 용량(Capacity)은 벡터의 저장 공간을 의미한다.

동적 배열을 재할당하는 경우에는 새 메모리를 할당 받아 전체 요소를 복사한다.
하지만 만약 벡터의 용량이 삽입되는 요소보다 클 경우에는 단순히 벡터의 크기만 바꾸어도 되기에 더 효율적이다.

따라서 벡터의 크기와 용량을 적절하게 설정하는 것이 중요하다.

##### **예시**
```cpp
v.capacity();		// 벡터의 용량 반환
v.resize(5);			// 벡터의 크기 재설정
v.reserve(10);		// 벡터의 용량 재설정
```

<br/>

-----------------

<br/>

### **3. 동적 배열 구현**
```cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

template<typename T>
class DynamicArray
{
	// 변수
	T* data;
	size_t n;

public:
	// 생성자
	DynamicArray(int n)
	{
		this->n = n;
		data = new T[n];
	}

	// 복사 생성자
	DynamicArray(const DynamicArray<T>& other)
	{
		this->n = other.n;
		data = new T[n];

		for (int i = 0; i < n; i++)
		{
			data[i] = other[i];
		}
	}

	// 소멸자
	~DynamicArray()
	{
		delete[] data;
	}

	size_t size() const
	{
		return n;
	}

	const T& at(int index) const
	{
		if (index < n)
		{
			return data[index];
		}
		throw "Index out of Range";
	}

	T* begin()
	{
		return data;
	}

	const T* begin() const
	{
		return data;
	}

	T* end()
	{
		return data + n;
	}

	const T* end() const
	{
		return data + n;
	}

	T& operator[] (int index)
	{
		return data[index];
	}

	friend DynamicArray<T> operator+ (const DynamicArray<T>& arr1, const DynamicArray<T>& arr2)
	{
		DynamicArray<T> result(arr1.size() + arr2.size());

		copy(arr1.begin(), arr1.end(), result.begin());
		copy(arr2.begin(), arr2.end(), result.begin() + arr1.size());

		return result;
	}

	void push_back(const T& value)
	{
		T* newData = new T[n + 1];

		for (int i = 0; i < n; i++)
		{
			newData[i] = data[i];
		}

		newData[n] = value;

		delete[] data;

		data = newData;
		++n;
	}

	T pop_back()
	{
		if (n == 0)
		{
			throw "Index out of Range";
		}

		return data[--n];
	}
};

int main()
{
	DynamicArray<int> arr1(0);

	int a, b, c;
	cin >> a >> b >> c;

	arr1.push_back(a);
	arr1.push_back(b);
	arr1.push_back(c);
	
	cout << arr1.pop_back() << "\n";
	cout << arr1.size() << "\n";
	cout << arr1.at(1);

	return 0;
}
```

##### **결과**
![Desktop View](/assets/img/DynamicArray1.jpg){: w="700" h="400" }
