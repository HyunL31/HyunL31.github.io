---
title : "[자료구조] 큐 (Queue)"
date : 2026-01-25 15:32:00 +0900
categories : [Dev / CS]
tags : [computer, science, cpp, opp, queue, data, structure, algorithm]
comments : true
pin : true
---

## 큐 (Queue)

### 1. 큐 (Queue)
**큐 (Queue)** 이란 **선입선출 (FIFO)** 형태의 자료구조이다.
가장 먼저 삽입된 요소가 가장 먼저 나오게 된다.

**Front**는 출구를 의미한다. 즉, 데이터가 나오는 통로이다.
**Rear**는 입구를 의미한다. 즉, 데이터가 들어가는 통로이다.

<br/>

-----------------

<br/>

### 2. 큐 (Queue)의 종류
#### **(1) 선형 큐 (Linear Queue)**
**특징**
- 가장 기본적인 큐의 형태이다.
- front에서만 dequeue가 가능하고 rear에서만 enqueue가 가능하다.

**단점**
- 앞쪽 공간의 재사용이 불가능하다.
- 큐가 다 차지 않아도 enqueue가 불가능한 상황이 생길 수 있다.
- 앞쪽 공간을 사용하려면 모든 요소를 shift 해야 하기에 $O(n)$이 걸린다.

![Desktop View](/assets/img/queue1.jpg){: w="700" h="400" }


#### **(2) 원형 큐 (Linear Queue)**
**특징**
- 배열을 원처럼 사용한다.
- % size로 큐를 순회한다.
- dequeue를 해도 앞쪽 공간을 사용할 수 있다.

**장점**
- enqueue와 dequeue를 $O(1)$ 안에 할 수 있다.
- 메모리 효율이 좋다.

![Desktop View](/assets/img/queue2.jpg){: w="700" h="400" }


#### **(3) 우선순위 큐 (Priority Queue)**
**특징**
- 들어오는 순서가 아닌 **우선순위**가 먼저이다.
- 내부적으로 **힙(heap)**을 사용해 구현한다.
- C++ : ```priority_queue```

![Desktop View](/assets/img/queue3.jpg){: w="700" h="400" }

<br/>

-----------------

<br/>

### **3. 큐의 주요 연산**
- enqueue() / push() : 데이터 삽입
- dequeue() / pop() : 맨 앞 데이터 제거
- front() : 맨 앞 데이터 확인
- back() : 맨 뒤 데이터 확인
- empty() : 큐가 비어있는지 확인

#### **주요 연산 사용 예시**
```cpp
#include <queue>
#include <iostream>

using namespace std;

int main()
{
	queue<int> q;

	q.push(10);
	q.push(20);
	q.push(30);
	cout << q.front() << "\n";	// 10

	q.pop();
	cout << q.front() << "\n";	// 20
	cout << q.back() << "\n";	// 30

	cout << q.size() << "\n";	// 2

	cout << q.empty() << "\n";	// 0
}
```
<br/>

-----------------

<br/>

### **4. 큐의 사용 예시**
- 프린터 대기열
- 운영체제 프로세스 스케줄링
- BFS (넓이 우선 탐색)
- 네트워크 패킷 처리
- 게임 이벤트 처리

<br/>

-----------------

<br/>

### **5. 큐의 구현**
```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

template <typename T>
class Queue
{
private:
	T* data;
	int n;
	int first;
	int rear;
	size_t capacity;

public:
	Queue(size_t capacity = 10)
	{
		this->capacity = capacity;

		data = new T[capacity];
		first = 0;
		rear = 0;
		n = 0;
	}

	~Queue()
	{
		delete[] data;
	}

	size_t size()
	{
		return n;
	}

	void resize()
	{
		size_t newCapacity = capacity * 2;
		T* newData = new T[newCapacity];

		for (int i = 0; i < n; i++)
		{
			newData[i] = data[(first + i) % capacity];
		}

		delete[] data;

		data = newData;
		capacity = newCapacity;

		first = 0;
		rear = n;
	}

	void enqueue(T temp)
	{
		if (full())
		{
			resize();
		}

		data[rear] = temp;

		rear = (rear + 1) % capacity;
		n++;
	}

	void dequeue()
	{
		if (empty())
		{
			throw runtime_error("Queue is empty.");
		}

		first = (first + 1) % capacity;
		n--;
	}

	T front()
	{
		if (empty())
		{
			throw runtime_error("Queue is empty.");
		}

		return data[first];
	}

	T back()
	{
		if (empty())
		{
			throw runtime_error("Queue is empty.");
		}

		return data[(rear - 1 + capacity) % capacity];
	}

	bool empty()
	{
		return n == 0;
	}

	bool full()
	{
		return n == capacity;
	}
};

int main()
{
	Queue<int> q(3);

	q.enqueue(10);
	q.enqueue(20);
	q.enqueue(30);

	cout << "front: " << q.front() << endl; // 10
	cout << "back : " << q.back() << endl;  // 30
	cout << "size : " << q.size() << endl;  // 3

	q.dequeue();
	cout << "front: " << q.front() << endl; // 20
	cout << "back : " << q.back() << endl;  // 30
	cout << "size : " << q.size() << endl;  // 2

	q.enqueue(40);

	cout << "front: " << q.front() << endl; // 20
	cout << "back : " << q.back() << endl;  // 40
	cout << "size : " << q.size() << endl;  // 3

	q.enqueue(50);

	cout << "front: " << q.front() << endl; // 20
	cout << "back : " << q.back() << endl;  // 50
	cout << "size : " << q.size() << endl;  // 4

	while (!q.empty())
	{
		cout << q.front() << " ";	// 20 30 40 50
		q.dequeue();
	}

	cout << endl;

	cout << "\nEmpty? " << (q.empty() ? "YES" : "NO") << endl;

	return 0;
}

```
