---
title : "[OOP] 객체지향의 특징"
date : 2026-01-28 15:32:00 +0900
categories : [Dev / OOP]
tags : [computer, science, cpp, opp, language]
comments : true
pin : true
---

## 객체 지향의 4대 특징

### 1. 추상화 (Abstraction)
**추상화**란 객체의 공통적이고 핵심적인 부분만 뽑아 필요한 것만 보여주고, 나머지는 숨기는 것을 의미한다.
이를 통해 시스템을 단순화하고 이해하기 쉽게 만들고 사용자는 내부 구조를 몰라도 기능을 사용할 수 있다.
운전을 할 때 엔진 내부는 몰라도 핸들과 브레이크만 알면 되는 것과 마찬가지이다.

#### **예시**
```cpp
// 추상 클래스
public abstract class Enemy : MonoBehaviour
{
    public int hp;

    public abstract void Attack();

    public virtual void TakeDamage(int damage)
    {
        hp -= damage;
    }
}
```
```cpp
// 구현
public class WolfEnemy : Enemy
{
    public override void Attack()
    {
        Debug.Log("늑대 공격!");
    }
}
```

#### **추상 클래스와 인터페이스의 차이**
객체지향에서 추상화는 추상 클래스와 인터페이스를 통해 구현된다.
추상 클래스는 공통된 속성과 기능을 포함할 수 있는 반면, 인터페이스는 특정 기능에 대한 규칙만을 명시한다.

<br/>

-----------------

<br/>

### **2. 캡슐화 (Encapsulation)**
**캡슐화**란 데이터와 기능을 하나로 묶고 직접적인 접근을 막는 것을 의미한다.
이를 통해 객체 내부의 상태를 외부에서 함부로 건드리지 못하도록 보호하고, 잘못된 사용으로 인한 오류를 방지할 수 있다.

#### **예시**
```cpp
// private 접근 제어자로 변수 보
public class Player : MonoBehaviour
{
    [SerializeField]
    private int hp = 100;

    public void TakeDamage(int damage)
    {
        hp -= damage;
        if (hp <= 0) Die();
    }

    private void Die()
    {
        Debug.Log("플레이어 사망");
    }
}
```

<br/>

-----------------

<br/>

### **3. 상속 (Inheritance)**
**상속**이란 기존 클래스의 속성과 메서드를 자식 클래스가 물려받아 사용하는 것을 의미한다.
코드 재사용성을 높이고, 공통 기능을 효율적으로 관리하는 기법이다.

#### **예시**
```cpp
// 부모 클래스
public abstract class Enemy : MonoBehaviour
{
    public int hp;

    public abstract void Attack();

    public virtual void TakeDamage(int damage)
    {
        hp -= damage;
    }
}
```
```cpp
// 자식 클래스
public class BombEnemy : Enemy
{
    public override void Attack()
    {
        Explode();
    }

    void Explode()
    {
        Debug.Log("폭발!");
    }
}
```

<br/>

-----------------

<br/>

### **4. 다형성 (Polymorphism)**
**다형성**이란 같은 메서드이지만 다른 기능을 갖는 것을 의미한다.
같은 타입의 참조 변수가 다른 객체를 가리킬 수 있다.
이를 통해 조건문 없이도 다양한 객체를 동일한 방식으로 처리할 수 있다.
 
 #### **예시**
```cpp
Enemy[] enemies = FindObjectsOfType<Enemy>();

// 각 enemy가 다른 공격 형태를 갖고 있다.
foreach (Enemy e in enemies)
{
    e.Attack();
}
```

<br/>

-----------------

<br/>
