---
title : "[자료구조] 리스트 (List)"
date : 2026-01-20 17:11:00 +0900
categories : [Dev / CS]
tags : [computer, science, data, structure, stl, list]
comments : true
pin : true
---

## 리스트 (List)

### 1. 리스트 (List)
**리스트**란 여러 개의 데이터를 순서대로 나열한 자료구조이다.
연속된 메모리에 데이터를 저장하는 배열과 달리 리스트는 메모리의 연속 여부와 상관없이 데이터를 저장한다.

<br/>

-----------------

<br/>

### **2. 리스트의 특징**
- 배열과 달리 동적 크기를 가진다.
- 삽입과 삭제가 빠르다.
- 인덱스 접근이 불가능하다.

<br/>

-----------------

<br/>

### **3. 연결 리스트 (Linked List)**
각 데이터가 다음 데이터의 **주소**를 저장한다.
메모리가 연속되지 않더라도 저장 가능하다.

#### **연결 리스트의 구조**
- **노드** : 데이터와 다음 주소를 가리키는 포인터
- **Head** : 첫 번째 노드를 가리키는 포인터
- **Tail** : 마지막 노드

![Desktop View](/assets/img/list1.jpg){: w="700" h="400" }


#### **연결 리스트의 종류**
- **단일 연결 리스트** : 한 쪽으로만 이동 가능

![Desktop View](/assets/img/list7.jpg){: w="700" h="400" }


- **이중 연결 리스트** : 양방향으로 이동 가능

![Desktop View](/assets/img/list2.jpg){: w="700" h="400" }


- **원형 연결 리스트** : Tail에서 Head로 이동 가능

![Desktop View](/assets/img/list3.jpg){: w="700" h="400" }


#### **연결 리스트의 탐색**
연결 리스트는 **인덱스로 접근이 불가**하다.
따라서 원하는 데이터에 접근하기 위해서는 첫 번째 노드부터 탐색해야 한다.

![Desktop View](/assets/img/list4.jpg){: w="700" h="400" }


#### **연결 리스트의 삽입**
연결 리스트는 각 노드가 포인터로 연결되어 있기에 포인터만 수정하면 $O(1)$에 삽입 가능하다.

![Desktop View](/assets/img/list5.jpg){: w="700" h="400" }


#### **연결 리스트의 삭제**
삽입과 마찬가지로 포인터만 수정하여 $O(1)$에 삭제가 가능하다.

![Desktop View](/assets/img/list6.jpg){: w="700" h="400" }


### **4. 연결 리스트의 장단점**
**장점**
- 삽입과 삭제가 빠르다.
- 메모리 연속성이 필요없다.
- 구조 변경이 유연하다.
- 동적으로 크기 변경이 가능하다.

**단점**
- 접근 속도가 느리다.
- 메모리 사용량이 증가한다.
- 구현이 복잡하다.
- 캐시 지역성이 낮다.

<br/>

-----------------

<br/>

### **5. 연결 리스트 구현**
```cpp
#include <iostream>

using namespace std;

template <typename T>
class LinkedList
{
	struct node
	{
		T data;
		node* next;
	};

private:
	node* head;
	node* tail;

public:
	LinkedList()
	{
		head = NULL;
		tail = NULL;
	}

	~LinkedList()
	{
		node* current = head;

		while (current)
		{
			node* nextNode = current->next;

			delete current;

			current = nextNode;
		}
	}

	void AddFront(T temp)
	{
		node* newNode = new node;

		newNode->data = temp;
		newNode->next = head;

		if (head == NULL)
		{
			head = newNode;
			tail = newNode;
		}
		else
		{
			head = newNode;
		}
	}

	void AddBack(T temp)
	{
		node* newNode = new node;

		newNode->data = temp;
		newNode->next = NULL;

		if (tail == NULL)
		{
			head = newNode;
			tail = newNode;
		}
		else
		{
			tail->next = newNode;
			tail = newNode;
		}
	}

	void InsertNode(node* prev, T temp)
	{
		if (prev == NULL)
		{
			return;
		}

		node* newNode = new node;

		newNode->data = temp;
		newNode->next = prev->next;

		prev->next = newNode;

		if (prev == tail)
		{
			tail = newNode;
		}
	}

	void DeleteNode(node* prev)
	{
		if (prev == NULL)
		{
			return;
		}

		node* current = prev->next;

		prev->next = current->next;

		if (current == tail)
		{
			tail = prev;
		}

		delete current;
	}

	node* GetHead()
	{
		return head;
	}

	node* GetTail()
	{
		return tail;
	}

	void Display(node* head)
	{
		node* current = head;

		while (current)
		{
			cout << current->data << " ";

			current = current->next;
		}
	}
};

int main()
{
	LinkedList<int> list;

	cout << "AddFront 테스트" << endl;
	list.AddFront(3);
	list.AddFront(2);
	list.AddFront(1);

	list.Display(list.GetHead());
	cout << endl;

	cout << "AddBack 테스트" << endl;
	list.AddBack(4);
	list.AddBack(5);

	list.Display(list.GetHead());
	cout << endl;

	cout << "InsertNode 테스트 (head 뒤에 삽입)" << endl;
	list.InsertNode(list.GetHead(), 99);

	list.Display(list.GetHead());
	cout << endl;

	cout << "DeleteNode 테스트 (head 뒤 노드 삭제)" << endl;
	list.DeleteNode(list.GetHead());

	list.Display(list.GetHead());
	cout << endl;

	cout << "tail 확인" << endl;
	cout << "tail data: " << list.GetTail()->data << endl;

	return 0;
}
```
