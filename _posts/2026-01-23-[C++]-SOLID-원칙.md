---
title : "[C++] SOLID 원칙"
date : 2026-01-23 15:34:00 +0900
categories : [Dev / Language]
tags : [computer, science, language, cpp, csharp, unity, opp, solid]
comments : true
pin : true
---

## SOLID 원칙

### 1. SOLID 원칙
**SOLID 원칙**이란 객체지향 설계에서 **유지보수성, 확장성, 가독성**을 높이기 위한 5가지 원칙을 의미한다.

<br/>

-----------------

<br/>

### **2. SRP (Single Responsibility Principle)**
**단일 책임 원칙**이란 클래스는 하나의 책임만을 가져야 한다는 원칙이다.
이 원칙에 의해 스크립트를 변경하는 이유는 오직 하나여야 한다.

#### **SRP  위반 시 문제점**
- 특정 기능을 수정할 때 다른 기능에 영향을 미쳐 버그가 발생할 확률이 높다.
- 유지 보수가 힘들어진다.
- 가독성이 좋지 않다. 

#### **SRP 예시**
```csharp
// 저장 및 로드, 적 스폰, BGM 재생 등
// 한 스크립트가 너무 많은 역할을 담당한다.
public class GameManager : MonoBehaviour
{
    public int score;
    public void SaveData() {}
    public void LoadData() {}
    public void SpawnEnemy() {}
    public void PlayBGM() {}
}
```
```csharp
// 결과 판정 역할만을 담당한다.
public class GameManager : MonoBehaviour
{
    public void GameOver() {}
    public void GameClear() {}
}
```

#### **SRP 주의점**
- 과도하게 스크립트를 분리할 경우 오히려 유지 보수가 어려워진다.
- 책임의 기준은 **변경의 이유**이다.

<br/>

-----------------

<br/>

### **3. OCP (Open - Closed Principle)**
**개방 - 폐쇄 원칙**이란 확장에는 열려있고 수정에는 닫혀있어야 한다는 원칙이다.
기능 추가 시 기존 코드를 수정하지 않도록 설계해야 한다.

#### **OCP 위반 시 문제점**
- 특정 기능을 수정할 때 다른 기능에 영향을 미쳐 버그가 발생할 확률이 높다.
- 수정할 때마다 코드 구조에 영향을 미쳐 유지보수성이 떨어진다.

#### **OCP 예시**
```csharp
// 기능을 추가할 때마다 if문을 수정해야한다.
void Attack(string enemyType)
{
    if (enemyType == "Goblin") {}
    else if (enemyType == "Boss") {}
}
```
```csharp
// 적의 유형마다 클래스를 추가하면 기존 코드를 수정하지 않고 사용할 수 있다.
public abstract class Enemy : MonoBehaviour
{
    public abstract void Attack();
}

public class Goblin : Enemy
{
    public override void Attack() {}
}

public class Boss : Enemy
{
    public override void Attack() {}
}

Enemy enemy = GetComponent<Enemy>();
enemy.Attack();
```

#### **OCP 주의점**
- 확장이 아닌 **수정**이 필요한 경우도 있다.
- Unity에서는 Inspector 의존성이 강해질 수 있다.
-  조건문 제거가 목적이 되어서는 안된다.
- 단순한 기능에 사용 시 오히려 구조가 복잡해질 가능성이 높다.

<br/>

-----------------

<br/>

### **4. LSP (Liskov Substitution Principle)**
**리스코프 치환 원칙**이란 자식 클래스가 부모 클래스를 완전히 대체할 수 있어야 한다는 원칙이다.
상속은 **is - a** 관계일 때만 사용해야한다. 

#### **LSP 위반 시 문제점**
- 다형성이 깨진다.
- 예외가 발생하기 쉽다.

#### **LSP 예시**
```csharp
// enemy.Move() 호출 시 에러
public class Enemy : MonoBehaviour
{
    public virtual void Move() {}
}

public class Turret : Enemy
{
    public override void Move()
    {
        throw new Exception("안 움직임");
    }
}
```
```csharp
// enemy가 움직이는 경우에만 Move() 호출
public interface IMovable
{
    void Move();
}

public class Enemy : MonoBehaviour {}
public class Goblin : Enemy, IMovable {}
public class Turret : Enemy {}

if (enemy is IMovable movable)
{
	movable.Move();
}
```


<br/>

-----------------

<br/>

### **5. ISP (Interface Segregation Principle)**
**인터페이스 분리 원칙**이란 사용하지 않는 메서드를 포함한 인터페이스를 만들지 말라는 의미이다.
목적 별로 작은 인터페이스를 여러 개 만드는 것이 좋다는 원칙이다.

#### **ISP 위반 시 문제점**
- 필요하지 않은 메서드까지 구현하므로 유지 보수가 어려워진다.
- 불필요한 의존성이 생긴다.

#### **ISP 예시**
```csharp
// Enemy의 종류에 따라 필요하지 않은 메서드도 구현해야한다. 
public interface IEnemy
{
    void Move();
    void Shoot();
    void Explode();
}
```
```csharp
// 각 Enemy 별 필요한 메서드만 사용할 수 있다.
public interface IMovable { void Move(); }
public interface IShootable { void Shoot(); }
public interface IExplodable { void Explode(); }
public class Slime : MonoBehaviour, IMovable {}
public class Turret : MonoBehaviour, IShootable {}
```

<br/>

-----------------

<br/>

### **6. DIP (Dependency Inversion Principle)**
**의존성 역전 원칙**이란 구체 클래스가 아닌 추상 클래스에 의존하라는 원칙이다.
new를 남발하지 말고 인터페이스나 추상 클래스에 의존하라는 원칙이다.

#### **DIP 위반 시 문제점**
- 결합도가 높아진다.
- 코드의 유연성이 떨어지고 재사용이 어려워진다.

#### **DIP 예시**
```csharp
// SaveManager가 바뀐다면 GameManager도 수정해야 한다.
public class GameManager : MonoBehaviour
{
    public SaveManager saveManager;
}
```
```csharp
// GameManager는 Service 인터페이스에만 의존한다.
public interface ISaveService
{
    void Save();
}

public class JsonSaveService : MonoBehaviour, ISaveService {}

public class GameManager : MonoBehaviour
{
    [SerializeField] private MonoBehaviour saveService;
    private ISaveService SaveService;

    void Awake()
    {
        SaveService = saveService as ISaveService;
    }
}
```

<br/>

-----------------

<br/>
