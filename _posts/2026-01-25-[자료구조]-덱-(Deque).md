---
title : "[자료구조] 덱 (Deque)"
date : 2026-01-25 20:31:00 +0900
categories : [Dev / CS]
tags : [computer, science, cpp, opp, deque, data, structure, algorithm]
comments : true
pin : true
---

## 덱 (Deque : Double Ended Queue)

### 1. 덱 (Deque)
**덱 (Deque)** 이란 **큐**와 비슷한 자료구조이다.
하지만 큐와 달리 **Front**와 **Rear** 모두에서 삽입과 삭제가 가능하다.
따라서 **큐**와 **스택**의 성질을 모두 가지고 있다고 할 수 있으며 관련 연산을 모두 $O(1)$ 안에 할 수 있다.


![Desktop View](/assets/img/deque1.jpg){: w="700" h="400" }

<br/>

-----------------

<br/>

### **2. 덱의 주요 연산**
- push_front() : 맨 앞에 데이터 삽입
- push_back() : 맨 뒤에 데이터 삽입
- pop_front() : 맨 앞 데이터 삭제
- pop_back() : 맨 뒤 데이터 삭제
- front() : 맨 앞 데이터 반환
- back() : 맨 뒤 데이터 반환
- size() : 덱의 크기 반환
- empty() : 덱이 비어있는지 반환


#### **주요 연산 사용 예시**
```cpp
#include <deque>
#include <iostream>

using namespace std;

int main()
{
	deque<int> q;

	q.push_front(10);
	q.push_front(20);
	q.push_back(30);
	cout << q.front() << "\n";	// 20

	q.pop_back();
	q.pop_front();
	cout << q.front() << "\n";	// 10
	cout << q.back() << "\n";	// 10

	cout << q.size() << "\n";	// 2

	cout << q.empty() << "\n";	// 0
}
```
<br/>

-----------------

<br/>

### **3. 덱의 사용 예시**
- 슬라이딩 윈도우 문제
- 최근 or 오래된 데이터 관리
- 우선순위 큐 (heap 대신)
- 양방향 탐색

<br/>

-----------------

<br/>

### **4. 덱의 구현**
```cpp
#include <iostream>
#include <stdexcept>

using namespace std;

template <typename T>
class Deque
{
	struct node
	{
		T data;
		node* next;
		node* prev;
	};

private:
	node* first;
	node* rear;
	size_t n;

public:
	Deque()
	{
		first = NULL;
		rear = NULL;
		n = 0;
	}

	~Deque()
	{
		node* current = first;

		while (current)
		{
			node* nextNode = current->next;

			delete current;

			current = nextNode;
		}
	}

	size_t size()
	{
		return n;
	}

	void push_front(T temp)
	{
		node* newNode = new node;
		newNode->data = temp;

		newNode->next = first;
		newNode->prev = NULL;

		if (first != NULL)
		{
			first->prev = newNode;
		}
		else
		{
			rear = newNode;
		}

		first = newNode;

		n++;
	}

	void push_back(T temp)
	{
		node* newNode = new node;
		newNode->data = temp;

		newNode->next = NULL;
		newNode->prev = rear;

		if (rear != NULL)
		{
			rear->next = newNode;
		}
		else
		{
			first = newNode;
		}

		rear = newNode;

		n++;
	}

	void pop_front()
	{
		if (n == 0)
		{
			throw runtime_error("Deque is empty.");
		}

		node* temp = first;
		first = first->next;

		if (first != NULL)
		{
			first->prev = NULL;
		}
		else
		{
			rear = NULL;
		}

		delete temp;

		n--;
	}

	void pop_back()
	{
		if (n == 0)
		{
			throw runtime_error("Deque is empty.");
		}

		node* temp = rear;
		rear = rear->prev;

		if (rear != NULL)
		{
			rear->next = NULL;
		}
		else
		{
			first = NULL;
		}

		delete temp;

		n--;
	}

	T front()
	{
		if (n == 0)
		{
			throw runtime_error("Deque is empty.");
		}

		return first->data;
	}

	T back()
	{
		if (n == 0)
		{
			throw runtime_error("Deque is empty.");
		}

		return rear->data;
	}

	bool empty()
	{
		return n == 0;
	}
};

int main()
{
	Deque<int> q;

	q.push_front(10);
	q.push_back(20);
	q.push_front(5);
	q.push_back(30);

	cout << q.size() << endl;	// 4
	cout << q.front() << endl;	// 5
	cout << q.back() << endl;	// 30

	q.pop_front();
	cout << q.front() << endl;	// 10
	cout << q.size() << endl;	// 3

	q.pop_back();
	cout << q.back() << endl;	// 20
	cout << q.size() << endl;	// 2

	while (!q.empty())
	{
		cout << q.front() << endl;	// 10, 20
		q.pop_front();
	}

	cout << q.empty() << endl;	// 1

	try
	{
		q.pop_back();
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;	// "Deque is empty."
	}

	return 0;
}
```
